/**********************************************************
 * @file   seamless_noise_generator_2d.h
 * @author jan
 * @date   7/14/18
 * ********************************************************
 * @brief
 * @details
 **********************************************************/
#ifndef PERLINNOISE_SEAMLESS_NOISE_GENERATOR_2D_H
#define PERLINNOISE_SEAMLESS_NOISE_GENERATOR_2D_H

#include <random>

#include "point.h"

/**
 * Generates seamless noise in 2 dimensions.
 *
 * @details Seamless noise is generated by mapping a four-dimensional Clifford torus to 2 dimensions.
 *
 * @tparam Gen    A four-dimensional noise generator, eg. perlin_noise_generator or fractal_noise_generator
 * @tparam Width  Width of the noise function until it repeats
 * @tparam Height Height of the noise function until it repeats
 */
template<class Gen,
        typename Gen::grid_coord_t Width,
        typename Gen::grid_coord_t Height>
class seamless_noise_generator_2d
{
public:
    static_assert(Gen::dimensions == 4, "Must use a 4D generator");
    static_assert(Width > 0, "Width must be positive");
    static_assert(Height > 0, "Height must be positive");

    using result_t = typename Gen::result_t;
    using grid_coord_t = typename Gen::grid_coord_t;

    static constexpr const int dimensions = 2;

    /**
     * @param seed Random seed for noise generation
     */
    explicit seamless_noise_generator_2d(std::uint_fast32_t seed = std::random_device()()) noexcept
            : m_noiseGen(seed)
    {
    }

    /**
     * Evaluate the noise function at a given point.
     *
     * @param p Point of evaluation
     * @return  Noise function value at the specified point
     */
    result_t at(point<result_t, dimensions> const& p) const noexcept
    {
        constexpr result_t const pi = 3.1415926535897932384626433832795028841971;
        constexpr result_t const two_pi = 2 * pi;

        auto s = p[0] / static_cast<result_t>(Width);
        auto t = p[1] / static_cast<result_t>(Height);

        auto multiplier_x = static_cast<result_t>(Width) / two_pi;
        auto multiplier_y = static_cast<result_t>(Height) / two_pi;
        auto nx = std::cos(s * two_pi) * multiplier_x;
        auto ny = std::cos(t * two_pi) * multiplier_y;
        auto nz = std::sin(s * two_pi) * multiplier_x;
        auto nw = std::sin(t * two_pi) * multiplier_y;

        return m_noiseGen.at(point<result_t, 4>{nx, ny, nz, nw});
    }

private:
    Gen m_noiseGen;
};

#endif //PERLINNOISE_SEAMLESS_NOISE_GENERATOR_2D_H
