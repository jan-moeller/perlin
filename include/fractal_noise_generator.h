/**********************************************************
 * @file   fractal_noise_generator.h
 * @author jan
 * @date   7/14/18
 * ********************************************************
 * @brief
 * @details
 **********************************************************/
#ifndef PERLINNOISE_FRACTAL_NOISE_GENERATOR_H
#define PERLINNOISE_FRACTAL_NOISE_GENERATOR_H

#include <random>
#include <algorithm>

#include "point.h"
#include "math.h"

namespace noise
{
    template<class T>
    class hyperbolic_decay
    {
    public:
        constexpr T operator()(int i) const noexcept
        {
            return 1 / static_cast<T>(i + 1);
        }
    };

    template<class T, int B = 70>
    class exponential_decay
    {
    private:
        constexpr static T s_base = B / 100.f;
    public:
        constexpr T operator()(int i) const noexcept
        {
            return powi(s_base, i);
        }
    };

    template<class T, int B = -300>
    class polynomial_decay
    {
    private:
        constexpr static T s_exp = B / 100.f;
    public:
        constexpr T operator()(int i) const noexcept
        {
            return std::pow(i + 1, s_exp);
        }
    };

    template<class T, int B = -300>
    class gaussian_decay
    {
    private:
        constexpr static T s_stddev = static_powi<2>(B / 100.f);
    public:
        constexpr T operator()(int i) const noexcept
        {
            return std::pow(constants<T>::e, -static_powi<2>(i) / (2 * s_stddev));
        }
    };

    /**
     * Generates fractal noise in arbitrary dimensions.
     *
     * @details Fractal noise is generated by summing multiple coherent noise functions at increasing frequencies but with
     *          decreasing weight.
     *
     * @tparam Gen       A coherent noise generator such as perlin_noise_generator.
     * @tparam Octaves   Number of noise functions to add. Octave frequency doubles with every step, weight decreases
     *                   according to the given weighting function.
     * @tparam WeightFun Weighting function
     */
    template<class Gen,
            int Octaves = 3,
            class WeightFun = hyperbolic_decay<typename Gen::result_t>>
    class fractal_noise_generator
    {
    public:
        static_assert(Octaves > 0, "Must have at least one octave");

        using result_t = typename Gen::result_t;
        using grid_coord_t = typename Gen::grid_coord_t;

        static constexpr const int dimensions = Gen::dimensions;

        /**
         * @param seed Random seed for noise generation
         */
        explicit fractal_noise_generator(std::uint_fast32_t seed = std::random_device()()) noexcept
                : m_noiseGen(seed)
        {
            WeightFun weightFun;
            std::generate(m_weights.begin(), m_weights.end(), [&weightFun, i = 0]()mutable { return weightFun(i++); });
        }

        /**
         * Evaluate the noise function at a given point.
         *
         * @param p Point of evaluation
         * @return  Noise function value at the specified point
         */
        result_t at(point<result_t, dimensions> const& p) const noexcept
        {
            result_t result = 0;
            for (int i = 0; i < Octaves; ++i)
            {
                result += m_noiseGen.at(pointAtOctave(p, i + 1)) * m_weights[i];
            }

            return std::clamp(result, static_cast<result_t>(-1), static_cast<result_t>(1));
        }

    private:
        constexpr point<result_t, dimensions> pointAtOctave(point<result_t, dimensions> p, int octave) const noexcept
        {
            for (auto& e : p)
                e *= octave;
            return p;
        }

        Gen m_noiseGen;
        std::array<result_t, Octaves> m_weights;
    };

}

#endif //PERLINNOISE_FRACTAL_NOISE_GENERATOR_H
